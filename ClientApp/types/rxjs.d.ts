export class AjaxError {
    static stackTraceLimit: number;
    constructor(message: any, xhr: any, request: any);
    message: any;
    xhr: any;
    request: any;
    status: any;
    responseType: any;
    response: any;
}
export class AjaxResponse {
    constructor(originalEvent: any, xhr: any, request: any);
    originalEvent: any;
    xhr: any;
    request: any;
    status: any;
    responseType: any;
    response: any;
}
export function AjaxTimeoutError(xhr: any, request: any): void;
export namespace AjaxTimeoutError {
    const stackTraceLimit: number;
}
export class AnonymousSubject {
    static create(destination: any, source: any): any;
    constructor(destination: any, source: any);
    destination: any;
    source: any;
    asObservable(): any;
    audit(durationSelector: any): any;
    auditTime(duration: any, scheduler: any): any;
    buffer(closingNotifier: any): any;
    bufferCount(bufferSize: any, startBufferEvery: any): any;
    bufferTime(bufferTimeSpan: any, ...args: any[]): any;
    bufferToggle(openings: any, closingSelector: any): any;
    bufferWhen(closingSelector: any): any;
    combineAll(project: any): any;
    combineLatest(...args: any[]): any;
    complete(): void;
    concat(...args: any[]): any;
    concatAll(): any;
    concatMap(project: any, resultSelector: any): any;
    concatMapTo(innerObservable: any, resultSelector: any): any;
    count(predicate: any): any;
    debounce(durationSelector: any): any;
    debounceTime(dueTime: any, scheduler: any): any;
    defaultIfEmpty(defaultValue: any): any;
    delay(delay: any, scheduler: any): any;
    delayWhen(delayDurationSelector: any, subscriptionDelay: any): any;
    dematerialize(): any;
    distinct(keySelector: any, flushes: any): any;
    distinctUntilChanged(compare: any, keySelector: any): any;
    distinctUntilKeyChanged(key: any, compare: any): any;
    elementAt(index: any, defaultValue: any): any;
    error(err: any): void;
    every(predicate: any, thisArg: any): any;
    exhaust(): any;
    exhaustMap(project: any, resultSelector: any): any;
    expand(project: any, concurrent: any, scheduler: any): any;
    filter(predicate: any, thisArg: any): any;
    find(predicate: any, thisArg: any): any;
    findIndex(predicate: any, thisArg: any): any;
    first(predicate: any, resultSelector: any, defaultValue: any): any;
    flatMap(project: any, resultSelector: any, concurrent: any): any;
    flatMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    forEach(next: any, PromiseCtor: any): any;
    groupBy(keySelector: any, elementSelector: any, durationSelector: any, subjectSelector: any): any;
    ignoreElements(): any;
    isEmpty(): any;
    last(predicate: any, resultSelector: any, defaultValue: any): any;
    letBind(func: any): any;
    lift(operator: any): any;
    map(project: any, thisArg: any): any;
    mapTo(value: any): any;
    materialize(): any;
    max(comparer: any): any;
    merge(...args: any[]): any;
    mergeAll(concurrent: any): any;
    mergeMap(project: any, resultSelector: any, concurrent: any): any;
    mergeMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    mergeScan(accumulator: any, seed: any, concurrent: any): any;
    min(comparer: any): any;
    multicast(subjectOrSubjectFactory: any, selector: any): any;
    next(value: any): void;
    observeOn(scheduler: any, delay: any): any;
    onErrorResumeNext(...args: any[]): any;
    pairwise(): any;
    partition(predicate: any, thisArg: any): any;
    pipe(...args: any[]): any;
    pluck(...args: any[]): any;
    publish(selector: any): any;
    publishBehavior(value: any): any;
    publishLast(): any;
    publishReplay(bufferSize: any, windowTime: any, selectorOrScheduler: any, scheduler: any): any;
    race(...args: any[]): any;
    reduce(accumulator: any, seed: any, ...args: any[]): any;
    repeat(count: any): any;
    repeatWhen(notifier: any): any;
    retry(count: any): any;
    retryWhen(notifier: any): any;
    sample(notifier: any): any;
    sampleTime(period: any, scheduler: any): any;
    scan(accumulator: any, seed: any, ...args: any[]): any;
    sequenceEqual(compareTo: any, comparor: any): any;
    share(): any;
    shareReplay(bufferSize: any, windowTime: any, scheduler: any): any;
    single(predicate: any): any;
    skip(count: any): any;
    skipLast(count: any): any;
    skipUntil(notifier: any): any;
    skipWhile(predicate: any): any;
    startWith(...args: any[]): any;
    subscribe(observerOrNext: any, error: any, complete: any): any;
    subscribeOn(scheduler: any, delay: any): any;
    switchMap(project: any, resultSelector: any): any;
    switchMapTo(innerObservable: any, resultSelector: any): any;
    take(count: any): any;
    takeLast(count: any): any;
    takeUntil(notifier: any): any;
    takeWhile(predicate: any): any;
    throttle(durationSelector: any, config: any): any;
    throttleTime(duration: any, scheduler: any, config: any): any;
    timeInterval(scheduler: any): any;
    timeout(due: any, scheduler: any): any;
    timeoutWith(due: any, withObservable: any, scheduler: any): any;
    timestamp(scheduler: any): any;
    toArray(): any;
    toPromise(PromiseCtor: any): any;
    unsubscribe(): void;
    window(windowBoundaries: any): any;
    windowCount(windowSize: any, startWindowEvery: any): any;
    windowTime(windowTimeSpan: any, ...args: any[]): any;
    windowToggle(openings: any, closingSelector: any): any;
    windowWhen(closingSelector: any): any;
    withLatestFrom(...args: any[]): any;
    zip(...args: any[]): any;
    zipAll(project: any): any;
}
export class ArgumentOutOfRangeError {
    static stackTraceLimit: number;
    name: any;
    stack: any;
    message: any;
}
export class AsyncSubject {
    static create(destination: any, source: any): any;
    constructor(...args: any[]);
    value: any;
    hasNext: any;
    hasCompleted: any;
    asObservable(): any;
    audit(durationSelector: any): any;
    auditTime(duration: any, scheduler: any): any;
    buffer(closingNotifier: any): any;
    bufferCount(bufferSize: any, startBufferEvery: any): any;
    bufferTime(bufferTimeSpan: any, ...args: any[]): any;
    bufferToggle(openings: any, closingSelector: any): any;
    bufferWhen(closingSelector: any): any;
    combineAll(project: any): any;
    combineLatest(...args: any[]): any;
    complete(): void;
    concat(...args: any[]): any;
    concatAll(): any;
    concatMap(project: any, resultSelector: any): any;
    concatMapTo(innerObservable: any, resultSelector: any): any;
    count(predicate: any): any;
    debounce(durationSelector: any): any;
    debounceTime(dueTime: any, scheduler: any): any;
    defaultIfEmpty(defaultValue: any): any;
    delay(delay: any, scheduler: any): any;
    delayWhen(delayDurationSelector: any, subscriptionDelay: any): any;
    dematerialize(): any;
    distinct(keySelector: any, flushes: any): any;
    distinctUntilChanged(compare: any, keySelector: any): any;
    distinctUntilKeyChanged(key: any, compare: any): any;
    elementAt(index: any, defaultValue: any): any;
    error(error: any): void;
    every(predicate: any, thisArg: any): any;
    exhaust(): any;
    exhaustMap(project: any, resultSelector: any): any;
    expand(project: any, concurrent: any, scheduler: any): any;
    filter(predicate: any, thisArg: any): any;
    find(predicate: any, thisArg: any): any;
    findIndex(predicate: any, thisArg: any): any;
    first(predicate: any, resultSelector: any, defaultValue: any): any;
    flatMap(project: any, resultSelector: any, concurrent: any): any;
    flatMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    forEach(next: any, PromiseCtor: any): any;
    groupBy(keySelector: any, elementSelector: any, durationSelector: any, subjectSelector: any): any;
    ignoreElements(): any;
    isEmpty(): any;
    last(predicate: any, resultSelector: any, defaultValue: any): any;
    letBind(func: any): any;
    lift(operator: any): any;
    map(project: any, thisArg: any): any;
    mapTo(value: any): any;
    materialize(): any;
    max(comparer: any): any;
    merge(...args: any[]): any;
    mergeAll(concurrent: any): any;
    mergeMap(project: any, resultSelector: any, concurrent: any): any;
    mergeMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    mergeScan(accumulator: any, seed: any, concurrent: any): any;
    min(comparer: any): any;
    multicast(subjectOrSubjectFactory: any, selector: any): any;
    next(value: any): void;
    observeOn(scheduler: any, delay: any): any;
    onErrorResumeNext(...args: any[]): any;
    pairwise(): any;
    partition(predicate: any, thisArg: any): any;
    pipe(...args: any[]): any;
    pluck(...args: any[]): any;
    publish(selector: any): any;
    publishBehavior(value: any): any;
    publishLast(): any;
    publishReplay(bufferSize: any, windowTime: any, selectorOrScheduler: any, scheduler: any): any;
    race(...args: any[]): any;
    reduce(accumulator: any, seed: any, ...args: any[]): any;
    repeat(count: any): any;
    repeatWhen(notifier: any): any;
    retry(count: any): any;
    retryWhen(notifier: any): any;
    sample(notifier: any): any;
    sampleTime(period: any, scheduler: any): any;
    scan(accumulator: any, seed: any, ...args: any[]): any;
    sequenceEqual(compareTo: any, comparor: any): any;
    share(): any;
    shareReplay(bufferSize: any, windowTime: any, scheduler: any): any;
    single(predicate: any): any;
    skip(count: any): any;
    skipLast(count: any): any;
    skipUntil(notifier: any): any;
    skipWhile(predicate: any): any;
    startWith(...args: any[]): any;
    subscribe(observerOrNext: any, error: any, complete: any): any;
    subscribeOn(scheduler: any, delay: any): any;
    switchMap(project: any, resultSelector: any): any;
    switchMapTo(innerObservable: any, resultSelector: any): any;
    take(count: any): any;
    takeLast(count: any): any;
    takeUntil(notifier: any): any;
    takeWhile(predicate: any): any;
    throttle(durationSelector: any, config: any): any;
    throttleTime(duration: any, scheduler: any, config: any): any;
    timeInterval(scheduler: any): any;
    timeout(due: any, scheduler: any): any;
    timeoutWith(due: any, withObservable: any, scheduler: any): any;
    timestamp(scheduler: any): any;
    toArray(): any;
    toPromise(PromiseCtor: any): any;
    unsubscribe(): void;
    window(windowBoundaries: any): any;
    windowCount(windowSize: any, startWindowEvery: any): any;
    windowTime(windowTimeSpan: any, ...args: any[]): any;
    windowToggle(openings: any, closingSelector: any): any;
    windowWhen(closingSelector: any): any;
    withLatestFrom(...args: any[]): any;
    zip(...args: any[]): any;
    zipAll(project: any): any;
}
export class BehaviorSubject {
    static create(destination: any, source: any): any;
    constructor(_value: any);
    asObservable(): any;
    audit(durationSelector: any): any;
    auditTime(duration: any, scheduler: any): any;
    buffer(closingNotifier: any): any;
    bufferCount(bufferSize: any, startBufferEvery: any): any;
    bufferTime(bufferTimeSpan: any, ...args: any[]): any;
    bufferToggle(openings: any, closingSelector: any): any;
    bufferWhen(closingSelector: any): any;
    combineAll(project: any): any;
    combineLatest(...args: any[]): any;
    complete(): void;
    concat(...args: any[]): any;
    concatAll(): any;
    concatMap(project: any, resultSelector: any): any;
    concatMapTo(innerObservable: any, resultSelector: any): any;
    count(predicate: any): any;
    debounce(durationSelector: any): any;
    debounceTime(dueTime: any, scheduler: any): any;
    defaultIfEmpty(defaultValue: any): any;
    delay(delay: any, scheduler: any): any;
    delayWhen(delayDurationSelector: any, subscriptionDelay: any): any;
    dematerialize(): any;
    distinct(keySelector: any, flushes: any): any;
    distinctUntilChanged(compare: any, keySelector: any): any;
    distinctUntilKeyChanged(key: any, compare: any): any;
    elementAt(index: any, defaultValue: any): any;
    error(err: any): void;
    every(predicate: any, thisArg: any): any;
    exhaust(): any;
    exhaustMap(project: any, resultSelector: any): any;
    expand(project: any, concurrent: any, scheduler: any): any;
    filter(predicate: any, thisArg: any): any;
    find(predicate: any, thisArg: any): any;
    findIndex(predicate: any, thisArg: any): any;
    first(predicate: any, resultSelector: any, defaultValue: any): any;
    flatMap(project: any, resultSelector: any, concurrent: any): any;
    flatMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    forEach(next: any, PromiseCtor: any): any;
    getValue(): any;
    groupBy(keySelector: any, elementSelector: any, durationSelector: any, subjectSelector: any): any;
    ignoreElements(): any;
    isEmpty(): any;
    last(predicate: any, resultSelector: any, defaultValue: any): any;
    letBind(func: any): any;
    lift(operator: any): any;
    map(project: any, thisArg: any): any;
    mapTo(value: any): any;
    materialize(): any;
    max(comparer: any): any;
    merge(...args: any[]): any;
    mergeAll(concurrent: any): any;
    mergeMap(project: any, resultSelector: any, concurrent: any): any;
    mergeMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    mergeScan(accumulator: any, seed: any, concurrent: any): any;
    min(comparer: any): any;
    multicast(subjectOrSubjectFactory: any, selector: any): any;
    next(value: any): void;
    observeOn(scheduler: any, delay: any): any;
    onErrorResumeNext(...args: any[]): any;
    pairwise(): any;
    partition(predicate: any, thisArg: any): any;
    pipe(...args: any[]): any;
    pluck(...args: any[]): any;
    publish(selector: any): any;
    publishBehavior(value: any): any;
    publishLast(): any;
    publishReplay(bufferSize: any, windowTime: any, selectorOrScheduler: any, scheduler: any): any;
    race(...args: any[]): any;
    reduce(accumulator: any, seed: any, ...args: any[]): any;
    repeat(count: any): any;
    repeatWhen(notifier: any): any;
    retry(count: any): any;
    retryWhen(notifier: any): any;
    sample(notifier: any): any;
    sampleTime(period: any, scheduler: any): any;
    scan(accumulator: any, seed: any, ...args: any[]): any;
    sequenceEqual(compareTo: any, comparor: any): any;
    share(): any;
    shareReplay(bufferSize: any, windowTime: any, scheduler: any): any;
    single(predicate: any): any;
    skip(count: any): any;
    skipLast(count: any): any;
    skipUntil(notifier: any): any;
    skipWhile(predicate: any): any;
    startWith(...args: any[]): any;
    subscribe(observerOrNext: any, error: any, complete: any): any;
    subscribeOn(scheduler: any, delay: any): any;
    switchMap(project: any, resultSelector: any): any;
    switchMapTo(innerObservable: any, resultSelector: any): any;
    take(count: any): any;
    takeLast(count: any): any;
    takeUntil(notifier: any): any;
    takeWhile(predicate: any): any;
    throttle(durationSelector: any, config: any): any;
    throttleTime(duration: any, scheduler: any, config: any): any;
    timeInterval(scheduler: any): any;
    timeout(due: any, scheduler: any): any;
    timeoutWith(due: any, withObservable: any, scheduler: any): any;
    timestamp(scheduler: any): any;
    toArray(): any;
    toPromise(PromiseCtor: any): any;
    unsubscribe(): void;
    window(windowBoundaries: any): any;
    windowCount(windowSize: any, startWindowEvery: any): any;
    windowTime(windowTimeSpan: any, ...args: any[]): any;
    windowToggle(openings: any, closingSelector: any): any;
    windowWhen(closingSelector: any): any;
    withLatestFrom(...args: any[]): any;
    zip(...args: any[]): any;
    zipAll(project: any): any;
}
export class ConnectableObservable {
    static bindCallback(func: any, selector: any, scheduler: any): any;
    static bindNodeCallback(func: any, selector: any, scheduler: any): any;
    static combineLatest(...args: any[]): any;
    static concat(...args: any[]): any;
    static create(subscribe: any): any;
    static defer(observableFactory: any): any;
    static empty(scheduler: any): any;
    static forkJoin(...args: any[]): any;
    static from(ish: any, scheduler: any): any;
    static fromEvent(target: any, eventName: any, options: any, selector: any): any;
    static fromEventPattern(addHandler: any, removeHandler: any, selector: any): any;
    static fromPromise(promise: any, scheduler: any): any;
    static generate(initialStateOrOptions: any, condition: any, iterate: any, resultSelectorOrObservable: any, scheduler: any, ...args: any[]): any;
    static interval(period: any, scheduler: any): any;
    static merge(...args: any[]): any;
    static never(): any;
    static of(...args: any[]): any;
    static onErrorResumeNext(...args: any[]): any;
    static pairs(obj: any, scheduler: any): any;
    static race(...args: any[]): any;
    static range(start: any, count: any, scheduler: any): any;
    static timer(initialDelay: any, period: any, scheduler: any): any;
    static using(resourceFactory: any, observableFactory: any): any;
    static webSocket(urlConfigOrSource: any): any;
    static zip(...args: any[]): any;
    constructor(source: any, subjectFactory: any);
    source: any;
    subjectFactory: any;
    audit(durationSelector: any): any;
    auditTime(duration: any, scheduler: any): any;
    buffer(closingNotifier: any): any;
    bufferCount(bufferSize: any, startBufferEvery: any): any;
    bufferTime(bufferTimeSpan: any, ...args: any[]): any;
    bufferToggle(openings: any, closingSelector: any): any;
    bufferWhen(closingSelector: any): any;
    combineAll(project: any): any;
    combineLatest(...args: any[]): any;
    concat(...args: any[]): any;
    concatAll(): any;
    concatMap(project: any, resultSelector: any): any;
    concatMapTo(innerObservable: any, resultSelector: any): any;
    connect(): any;
    count(predicate: any): any;
    debounce(durationSelector: any): any;
    debounceTime(dueTime: any, scheduler: any): any;
    defaultIfEmpty(defaultValue: any): any;
    delay(delay: any, scheduler: any): any;
    delayWhen(delayDurationSelector: any, subscriptionDelay: any): any;
    dematerialize(): any;
    distinct(keySelector: any, flushes: any): any;
    distinctUntilChanged(compare: any, keySelector: any): any;
    distinctUntilKeyChanged(key: any, compare: any): any;
    elementAt(index: any, defaultValue: any): any;
    every(predicate: any, thisArg: any): any;
    exhaust(): any;
    exhaustMap(project: any, resultSelector: any): any;
    expand(project: any, concurrent: any, scheduler: any): any;
    filter(predicate: any, thisArg: any): any;
    find(predicate: any, thisArg: any): any;
    findIndex(predicate: any, thisArg: any): any;
    first(predicate: any, resultSelector: any, defaultValue: any): any;
    flatMap(project: any, resultSelector: any, concurrent: any): any;
    flatMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    forEach(next: any, PromiseCtor: any): any;
    getSubject(): any;
    groupBy(keySelector: any, elementSelector: any, durationSelector: any, subjectSelector: any): any;
    ignoreElements(): any;
    isEmpty(): any;
    last(predicate: any, resultSelector: any, defaultValue: any): any;
    letBind(func: any): any;
    lift(operator: any): any;
    map(project: any, thisArg: any): any;
    mapTo(value: any): any;
    materialize(): any;
    max(comparer: any): any;
    merge(...args: any[]): any;
    mergeAll(concurrent: any): any;
    mergeMap(project: any, resultSelector: any, concurrent: any): any;
    mergeMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    mergeScan(accumulator: any, seed: any, concurrent: any): any;
    min(comparer: any): any;
    multicast(subjectOrSubjectFactory: any, selector: any): any;
    observeOn(scheduler: any, delay: any): any;
    onErrorResumeNext(...args: any[]): any;
    pairwise(): any;
    partition(predicate: any, thisArg: any): any;
    pipe(...args: any[]): any;
    pluck(...args: any[]): any;
    publish(selector: any): any;
    publishBehavior(value: any): any;
    publishLast(): any;
    publishReplay(bufferSize: any, windowTime: any, selectorOrScheduler: any, scheduler: any): any;
    race(...args: any[]): any;
    reduce(accumulator: any, seed: any, ...args: any[]): any;
    refCount(): any;
    repeat(count: any): any;
    repeatWhen(notifier: any): any;
    retry(count: any): any;
    retryWhen(notifier: any): any;
    sample(notifier: any): any;
    sampleTime(period: any, scheduler: any): any;
    scan(accumulator: any, seed: any, ...args: any[]): any;
    sequenceEqual(compareTo: any, comparor: any): any;
    share(): any;
    shareReplay(bufferSize: any, windowTime: any, scheduler: any): any;
    single(predicate: any): any;
    skip(count: any): any;
    skipLast(count: any): any;
    skipUntil(notifier: any): any;
    skipWhile(predicate: any): any;
    startWith(...args: any[]): any;
    subscribe(observerOrNext: any, error: any, complete: any): any;
    subscribeOn(scheduler: any, delay: any): any;
    switchMap(project: any, resultSelector: any): any;
    switchMapTo(innerObservable: any, resultSelector: any): any;
    take(count: any): any;
    takeLast(count: any): any;
    takeUntil(notifier: any): any;
    takeWhile(predicate: any): any;
    throttle(durationSelector: any, config: any): any;
    throttleTime(duration: any, scheduler: any, config: any): any;
    timeInterval(scheduler: any): any;
    timeout(due: any, scheduler: any): any;
    timeoutWith(due: any, withObservable: any, scheduler: any): any;
    timestamp(scheduler: any): any;
    toArray(): any;
    toPromise(PromiseCtor: any): any;
    window(windowBoundaries: any): any;
    windowCount(windowSize: any, startWindowEvery: any): any;
    windowTime(windowTimeSpan: any, ...args: any[]): any;
    windowToggle(openings: any, closingSelector: any): any;
    windowWhen(closingSelector: any): any;
    withLatestFrom(...args: any[]): any;
    zip(...args: any[]): any;
    zipAll(project: any): any;
}
export namespace ConnectableObservable {
    function ajax(urlOrRequest: any): any;
    namespace ajax {
        function get(url: any, headers: any): any;
        function getJSON(url: any, headers: any): any;
        function patch(url: any, body: any, headers: any): any;
        function post(url: any, body: any, headers: any): any;
        function put(url: any, body: any, headers: any): any;
    }
}
export class EmptyError {
    static stackTraceLimit: number;
    name: any;
    stack: any;
    message: any;
}
export class Notification {
    static createComplete(): any;
    static createError(err: any): any;
    static createNext(value: any): any;
    constructor(kind: any, value: any, error: any);
    kind: any;
    value: any;
    error: any;
    hasValue: any;
    accept(nextOrObserver: any, error: any, complete: any): any;
    observe(observer: any): any;
    toObservable(): any;
}
export namespace Notification {
    const completeNotification: {
        accept: Function;
        do: Function;
        error: any;
        hasValue: boolean;
        kind: string;
        observe: Function;
        toObservable: Function;
        value: any;
    };
    const undefinedValueNotification: {
        accept: Function;
        do: Function;
        error: any;
        hasValue: boolean;
        kind: string;
        observe: Function;
        toObservable: Function;
        value: any;
    };
}
export class ObjectUnsubscribedError {
    static stackTraceLimit: number;
    name: any;
    stack: any;
    message: any;
}
export class Observable {
    static bindCallback(func: any, selector: any, scheduler: any): any;
    static bindNodeCallback(func: any, selector: any, scheduler: any): any;
    static combineLatest(...args: any[]): any;
    static concat(...args: any[]): any;
    static create(subscribe: any): any;
    static defer(observableFactory: any): any;
    static empty(scheduler: any): any;
    static forkJoin(...args: any[]): any;
    static from(ish: any, scheduler: any): any;
    static fromEvent(target: any, eventName: any, options: any, selector: any): any;
    static fromEventPattern(addHandler: any, removeHandler: any, selector: any): any;
    static fromPromise(promise: any, scheduler: any): any;
    static generate(initialStateOrOptions: any, condition: any, iterate: any, resultSelectorOrObservable: any, scheduler: any, ...args: any[]): any;
    static interval(period: any, scheduler: any): any;
    static merge(...args: any[]): any;
    static never(): any;
    static of(...args: any[]): any;
    static onErrorResumeNext(...args: any[]): any;
    static pairs(obj: any, scheduler: any): any;
    static race(...args: any[]): any;
    static range(start: any, count: any, scheduler: any): any;
    static timer(initialDelay: any, period: any, scheduler: any): any;
    static using(resourceFactory: any, observableFactory: any): any;
    static webSocket(urlConfigOrSource: any): any;
    static zip(...args: any[]): any;
    constructor(subscribe: any);
    audit(durationSelector: any): any;
    auditTime(duration: any, scheduler: any): any;
    buffer(closingNotifier: any): any;
    bufferCount(bufferSize: any, startBufferEvery: any): any;
    bufferTime(bufferTimeSpan: any, ...args: any[]): any;
    bufferToggle(openings: any, closingSelector: any): any;
    bufferWhen(closingSelector: any): any;
    combineAll(project: any): any;
    combineLatest(...args: any[]): any;
    concat(...args: any[]): any;
    concatAll(): any;
    concatMap(project: any, resultSelector: any): any;
    concatMapTo(innerObservable: any, resultSelector: any): any;
    count(predicate: any): any;
    debounce(durationSelector: any): any;
    debounceTime(dueTime: any, scheduler: any): any;
    defaultIfEmpty(defaultValue: any): any;
    delay(delay: any, scheduler: any): any;
    delayWhen(delayDurationSelector: any, subscriptionDelay: any): any;
    dematerialize(): any;
    distinct(keySelector: any, flushes: any): any;
    distinctUntilChanged(compare: any, keySelector: any): any;
    distinctUntilKeyChanged(key: any, compare: any): any;
    elementAt(index: any, defaultValue: any): any;
    every(predicate: any, thisArg: any): any;
    exhaust(): any;
    exhaustMap(project: any, resultSelector: any): any;
    expand(project: any, concurrent: any, scheduler: any): any;
    filter(predicate: any, thisArg: any): any;
    find(predicate: any, thisArg: any): any;
    findIndex(predicate: any, thisArg: any): any;
    first(predicate: any, resultSelector: any, defaultValue: any): any;
    flatMap(project: any, resultSelector: any, concurrent: any): any;
    flatMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    forEach(next: any, PromiseCtor: any): any;
    groupBy(keySelector: any, elementSelector: any, durationSelector: any, subjectSelector: any): any;
    ignoreElements(): any;
    isEmpty(): any;
    last(predicate: any, resultSelector: any, defaultValue: any): any;
    letBind(func: any): any;
    lift(operator: any): any;
    map(project: any, thisArg: any): any;
    mapTo(value: any): any;
    materialize(): any;
    max(comparer: any): any;
    merge(...args: any[]): any;
    mergeAll(concurrent: any): any;
    mergeMap(project: any, resultSelector: any, concurrent: any): any;
    mergeMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    mergeScan(accumulator: any, seed: any, concurrent: any): any;
    min(comparer: any): any;
    multicast(subjectOrSubjectFactory: any, selector: any): any;
    observeOn(scheduler: any, delay: any): any;
    onErrorResumeNext(...args: any[]): any;
    pairwise(): any;
    partition(predicate: any, thisArg: any): any;
    pipe(...args: any[]): any;
    pluck(...args: any[]): any;
    publish(selector: any): any;
    publishBehavior(value: any): any;
    publishLast(): any;
    publishReplay(bufferSize: any, windowTime: any, selectorOrScheduler: any, scheduler: any): any;
    race(...args: any[]): any;
    reduce(accumulator: any, seed: any, ...args: any[]): any;
    repeat(count: any): any;
    repeatWhen(notifier: any): any;
    retry(count: any): any;
    retryWhen(notifier: any): any;
    sample(notifier: any): any;
    sampleTime(period: any, scheduler: any): any;
    scan(accumulator: any, seed: any, ...args: any[]): any;
    sequenceEqual(compareTo: any, comparor: any): any;
    share(): any;
    shareReplay(bufferSize: any, windowTime: any, scheduler: any): any;
    single(predicate: any): any;
    skip(count: any): any;
    skipLast(count: any): any;
    skipUntil(notifier: any): any;
    skipWhile(predicate: any): any;
    startWith(...args: any[]): any;
    subscribe(observerOrNext: any, error: any, complete: any): any;
    subscribeOn(scheduler: any, delay: any): any;
    switchMap(project: any, resultSelector: any): any;
    switchMapTo(innerObservable: any, resultSelector: any): any;
    take(count: any): any;
    takeLast(count: any): any;
    takeUntil(notifier: any): any;
    takeWhile(predicate: any): any;
    throttle(durationSelector: any, config: any): any;
    throttleTime(duration: any, scheduler: any, config: any): any;
    timeInterval(scheduler: any): any;
    timeout(due: any, scheduler: any): any;
    timeoutWith(due: any, withObservable: any, scheduler: any): any;
    timestamp(scheduler: any): any;
    toArray(): any;
    toPromise(PromiseCtor: any): any;
    window(windowBoundaries: any): any;
    windowCount(windowSize: any, startWindowEvery: any): any;
    windowTime(windowTimeSpan: any, ...args: any[]): any;
    windowToggle(openings: any, closingSelector: any): any;
    windowWhen(closingSelector: any): any;
    withLatestFrom(...args: any[]): any;
    zip(...args: any[]): any;
    zipAll(project: any): any;
}
export namespace Observable {
    function ajax(urlOrRequest: any): any;
    namespace ajax {
        function get(url: any, headers: any): any;
        function getJSON(url: any, headers: any): any;
        function patch(url: any, body: any, headers: any): any;
        function post(url: any, body: any, headers: any): any;
        function put(url: any, body: any, headers: any): any;
    }
}
export class ReplaySubject {
    static create(destination: any, source: any): any;
    constructor(bufferSize: any, windowTime: any, scheduler: any);
    scheduler: any;
    asObservable(): any;
    audit(durationSelector: any): any;
    auditTime(duration: any, scheduler: any): any;
    buffer(closingNotifier: any): any;
    bufferCount(bufferSize: any, startBufferEvery: any): any;
    bufferTime(bufferTimeSpan: any, ...args: any[]): any;
    bufferToggle(openings: any, closingSelector: any): any;
    bufferWhen(closingSelector: any): any;
    combineAll(project: any): any;
    combineLatest(...args: any[]): any;
    complete(): void;
    concat(...args: any[]): any;
    concatAll(): any;
    concatMap(project: any, resultSelector: any): any;
    concatMapTo(innerObservable: any, resultSelector: any): any;
    count(predicate: any): any;
    debounce(durationSelector: any): any;
    debounceTime(dueTime: any, scheduler: any): any;
    defaultIfEmpty(defaultValue: any): any;
    delay(delay: any, scheduler: any): any;
    delayWhen(delayDurationSelector: any, subscriptionDelay: any): any;
    dematerialize(): any;
    distinct(keySelector: any, flushes: any): any;
    distinctUntilChanged(compare: any, keySelector: any): any;
    distinctUntilKeyChanged(key: any, compare: any): any;
    elementAt(index: any, defaultValue: any): any;
    error(err: any): void;
    every(predicate: any, thisArg: any): any;
    exhaust(): any;
    exhaustMap(project: any, resultSelector: any): any;
    expand(project: any, concurrent: any, scheduler: any): any;
    filter(predicate: any, thisArg: any): any;
    find(predicate: any, thisArg: any): any;
    findIndex(predicate: any, thisArg: any): any;
    first(predicate: any, resultSelector: any, defaultValue: any): any;
    flatMap(project: any, resultSelector: any, concurrent: any): any;
    flatMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    forEach(next: any, PromiseCtor: any): any;
    groupBy(keySelector: any, elementSelector: any, durationSelector: any, subjectSelector: any): any;
    ignoreElements(): any;
    isEmpty(): any;
    last(predicate: any, resultSelector: any, defaultValue: any): any;
    letBind(func: any): any;
    lift(operator: any): any;
    map(project: any, thisArg: any): any;
    mapTo(value: any): any;
    materialize(): any;
    max(comparer: any): any;
    merge(...args: any[]): any;
    mergeAll(concurrent: any): any;
    mergeMap(project: any, resultSelector: any, concurrent: any): any;
    mergeMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    mergeScan(accumulator: any, seed: any, concurrent: any): any;
    min(comparer: any): any;
    multicast(subjectOrSubjectFactory: any, selector: any): any;
    next(value: any): void;
    observeOn(scheduler: any, delay: any): any;
    onErrorResumeNext(...args: any[]): any;
    pairwise(): any;
    partition(predicate: any, thisArg: any): any;
    pipe(...args: any[]): any;
    pluck(...args: any[]): any;
    publish(selector: any): any;
    publishBehavior(value: any): any;
    publishLast(): any;
    publishReplay(bufferSize: any, windowTime: any, selectorOrScheduler: any, scheduler: any): any;
    race(...args: any[]): any;
    reduce(accumulator: any, seed: any, ...args: any[]): any;
    repeat(count: any): any;
    repeatWhen(notifier: any): any;
    retry(count: any): any;
    retryWhen(notifier: any): any;
    sample(notifier: any): any;
    sampleTime(period: any, scheduler: any): any;
    scan(accumulator: any, seed: any, ...args: any[]): any;
    sequenceEqual(compareTo: any, comparor: any): any;
    share(): any;
    shareReplay(bufferSize: any, windowTime: any, scheduler: any): any;
    single(predicate: any): any;
    skip(count: any): any;
    skipLast(count: any): any;
    skipUntil(notifier: any): any;
    skipWhile(predicate: any): any;
    startWith(...args: any[]): any;
    subscribe(observerOrNext: any, error: any, complete: any): any;
    subscribeOn(scheduler: any, delay: any): any;
    switchMap(project: any, resultSelector: any): any;
    switchMapTo(innerObservable: any, resultSelector: any): any;
    take(count: any): any;
    takeLast(count: any): any;
    takeUntil(notifier: any): any;
    takeWhile(predicate: any): any;
    throttle(durationSelector: any, config: any): any;
    throttleTime(duration: any, scheduler: any, config: any): any;
    timeInterval(scheduler: any): any;
    timeout(due: any, scheduler: any): any;
    timeoutWith(due: any, withObservable: any, scheduler: any): any;
    timestamp(scheduler: any): any;
    toArray(): any;
    toPromise(PromiseCtor: any): any;
    unsubscribe(): void;
    window(windowBoundaries: any): any;
    windowCount(windowSize: any, startWindowEvery: any): any;
    windowTime(windowTimeSpan: any, ...args: any[]): any;
    windowToggle(openings: any, closingSelector: any): any;
    windowWhen(closingSelector: any): any;
    withLatestFrom(...args: any[]): any;
    zip(...args: any[]): any;
    zipAll(project: any): any;
}
export const Scheduler: {
    animationFrame: {
        SchedulerAction: Function;
        actions: any[];
        active: boolean;
        flush: Function;
        now: Function;
        schedule: Function;
        scheduled: any;
    };
    asap: {
        SchedulerAction: Function;
        actions: any[];
        active: boolean;
        flush: Function;
        now: Function;
        schedule: Function;
        scheduled: any;
    };
    async: {
        SchedulerAction: Function;
        actions: any[];
        active: boolean;
        flush: Function;
        now: Function;
        schedule: Function;
        scheduled: any;
    };
    queue: {
        SchedulerAction: Function;
        actions: any[];
        active: boolean;
        flush: Function;
        now: Function;
        schedule: Function;
        scheduled: any;
    };
};
export class Subject {
    static create(destination: any, source: any): any;
    observers: any;
    closed: any;
    isStopped: any;
    hasError: any;
    thrownError: any;
    asObservable(): any;
    audit(durationSelector: any): any;
    auditTime(duration: any, scheduler: any): any;
    buffer(closingNotifier: any): any;
    bufferCount(bufferSize: any, startBufferEvery: any): any;
    bufferTime(bufferTimeSpan: any, ...args: any[]): any;
    bufferToggle(openings: any, closingSelector: any): any;
    bufferWhen(closingSelector: any): any;
    combineAll(project: any): any;
    combineLatest(...args: any[]): any;
    complete(): void;
    concat(...args: any[]): any;
    concatAll(): any;
    concatMap(project: any, resultSelector: any): any;
    concatMapTo(innerObservable: any, resultSelector: any): any;
    count(predicate: any): any;
    debounce(durationSelector: any): any;
    debounceTime(dueTime: any, scheduler: any): any;
    defaultIfEmpty(defaultValue: any): any;
    delay(delay: any, scheduler: any): any;
    delayWhen(delayDurationSelector: any, subscriptionDelay: any): any;
    dematerialize(): any;
    distinct(keySelector: any, flushes: any): any;
    distinctUntilChanged(compare: any, keySelector: any): any;
    distinctUntilKeyChanged(key: any, compare: any): any;
    elementAt(index: any, defaultValue: any): any;
    error(err: any): void;
    every(predicate: any, thisArg: any): any;
    exhaust(): any;
    exhaustMap(project: any, resultSelector: any): any;
    expand(project: any, concurrent: any, scheduler: any): any;
    filter(predicate: any, thisArg: any): any;
    find(predicate: any, thisArg: any): any;
    findIndex(predicate: any, thisArg: any): any;
    first(predicate: any, resultSelector: any, defaultValue: any): any;
    flatMap(project: any, resultSelector: any, concurrent: any): any;
    flatMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    forEach(next: any, PromiseCtor: any): any;
    groupBy(keySelector: any, elementSelector: any, durationSelector: any, subjectSelector: any): any;
    ignoreElements(): any;
    isEmpty(): any;
    last(predicate: any, resultSelector: any, defaultValue: any): any;
    letBind(func: any): any;
    lift(operator: any): any;
    map(project: any, thisArg: any): any;
    mapTo(value: any): any;
    materialize(): any;
    max(comparer: any): any;
    merge(...args: any[]): any;
    mergeAll(concurrent: any): any;
    mergeMap(project: any, resultSelector: any, concurrent: any): any;
    mergeMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    mergeScan(accumulator: any, seed: any, concurrent: any): any;
    min(comparer: any): any;
    multicast(subjectOrSubjectFactory: any, selector: any): any;
    next(value: any): void;
    observeOn(scheduler: any, delay: any): any;
    onErrorResumeNext(...args: any[]): any;
    pairwise(): any;
    partition(predicate: any, thisArg: any): any;
    pipe(...args: any[]): any;
    pluck(...args: any[]): any;
    publish(selector: any): any;
    publishBehavior(value: any): any;
    publishLast(): any;
    publishReplay(bufferSize: any, windowTime: any, selectorOrScheduler: any, scheduler: any): any;
    race(...args: any[]): any;
    reduce(accumulator: any, seed: any, ...args: any[]): any;
    repeat(count: any): any;
    repeatWhen(notifier: any): any;
    retry(count: any): any;
    retryWhen(notifier: any): any;
    sample(notifier: any): any;
    sampleTime(period: any, scheduler: any): any;
    scan(accumulator: any, seed: any, ...args: any[]): any;
    sequenceEqual(compareTo: any, comparor: any): any;
    share(): any;
    shareReplay(bufferSize: any, windowTime: any, scheduler: any): any;
    single(predicate: any): any;
    skip(count: any): any;
    skipLast(count: any): any;
    skipUntil(notifier: any): any;
    skipWhile(predicate: any): any;
    startWith(...args: any[]): any;
    subscribe(observerOrNext: any, error: any, complete: any): any;
    subscribeOn(scheduler: any, delay: any): any;
    switchMap(project: any, resultSelector: any): any;
    switchMapTo(innerObservable: any, resultSelector: any): any;
    take(count: any): any;
    takeLast(count: any): any;
    takeUntil(notifier: any): any;
    takeWhile(predicate: any): any;
    throttle(durationSelector: any, config: any): any;
    throttleTime(duration: any, scheduler: any, config: any): any;
    timeInterval(scheduler: any): any;
    timeout(due: any, scheduler: any): any;
    timeoutWith(due: any, withObservable: any, scheduler: any): any;
    timestamp(scheduler: any): any;
    toArray(): any;
    toPromise(PromiseCtor: any): any;
    unsubscribe(): void;
    window(windowBoundaries: any): any;
    windowCount(windowSize: any, startWindowEvery: any): any;
    windowTime(windowTimeSpan: any, ...args: any[]): any;
    windowToggle(openings: any, closingSelector: any): any;
    windowWhen(closingSelector: any): any;
    withLatestFrom(...args: any[]): any;
    zip(...args: any[]): any;
    zipAll(project: any): any;
}
export class Subscriber {
    static create(next: any, error: any, complete: any): any;
    constructor(destinationOrNext: any, error: any, complete: any, ...args: any[]);
    syncErrorValue: any;
    syncErrorThrown: any;
    syncErrorThrowable: any;
    isStopped: any;
    destination: any;
    add(teardown: any): any;
    complete(): void;
    error(err: any): void;
    next(value: any): void;
    remove(subscription: any): void;
    unsubscribe(): void;
}
export namespace Subscriber {
    const EMPTY: {
        add: Function;
        closed: boolean;
        remove: Function;
        unsubscribe: Function;
    };
}
export class Subscription {
    constructor(unsubscribe: any);
    closed: any;
    add(teardown: any): any;
    remove(subscription: any): void;
    unsubscribe(): void;
}
export namespace Subscription {
    const EMPTY: {
        add: Function;
        closed: boolean;
        remove: Function;
        unsubscribe: Function;
    };
}
export const Symbol: {
    iterator: symbol;
    observable: symbol;
    rxSubscriber: symbol;
};
export class TestScheduler {
    static frameTimeFactor: number;
    static now(): any;
    static parseMarbles(marbles: any, values: any, errorValue: any, materializeInnerObservables: any): any;
    static parseMarblesAsSubscriptions(marbles: any): any;
    constructor(assertDeepEqual: any);
    assertDeepEqual: any;
    hotObservables: any;
    coldObservables: any;
    flushTests: any;
    createColdObservable(marbles: any, values: any, error: any): any;
    createHotObservable(marbles: any, values: any, error: any): any;
    createTime(marbles: any): any;
    expectObservable(observable: any, unsubscriptionMarbles: any): any;
    expectSubscriptions(actualSubscriptionLogs: any): any;
    flush(): void;
    materializeInnerObservable(observable: any, outerFrame: any): any;
    schedule(work: any, delay: any, state: any): any;
}
export class TimeInterval {
    constructor(value: any, interval: any);
    value: any;
    interval: any;
}
export class TimeoutError {
    static stackTraceLimit: number;
    name: any;
    stack: any;
    message: any;
}
export class Timestamp {
    constructor(value: any, timestamp: any);
    value: any;
    timestamp: any;
}
export class UnsubscriptionError {
    static stackTraceLimit: number;
    constructor(errors: any);
    errors: any;
    name: any;
    stack: any;
    message: any;
}
export class VirtualTimeScheduler {
    static frameTimeFactor: number;
    static now(): any;
    constructor(SchedulerAction: any, maxFrames: any);
    maxFrames: any;
    frame: any;
    index: any;
    flush(): void;
    schedule(work: any, delay: any, state: any): any;
}
export namespace operators {
    function audit(durationSelector: any): any;
    function auditTime(duration: any, scheduler: any): any;
    function buffer(closingNotifier: any): any;
    function bufferCount(bufferSize: any, startBufferEvery: any): any;
    function bufferTime(bufferTimeSpan: any, ...args: any[]): any;
    function bufferToggle(openings: any, closingSelector: any): any;
    function bufferWhen(closingSelector: any): any;
    function catchError(selector: any): any;
    function combineAll(project: any): any;
    function combineLatest(...args: any[]): any;
    function concat(...args: any[]): any;
    function concatAll(): any;
    function concatMap(project: any, resultSelector: any): any;
    function concatMapTo(innerObservable: any, resultSelector: any): any;
    function count(predicate: any): any;
    function debounce(durationSelector: any): any;
    function debounceTime(dueTime: any, scheduler: any): any;
    function defaultIfEmpty(defaultValue: any): any;
    function delay(delay: any, scheduler: any): any;
    function delayWhen(delayDurationSelector: any, subscriptionDelay: any): any;
    function dematerialize(): any;
    function distinct(keySelector: any, flushes: any): any;
    function distinctUntilChanged(compare: any, keySelector: any): any;
    function distinctUntilKeyChanged(key: any, compare: any): any;
    function elementAt(index: any, defaultValue: any): any;
    function every(predicate: any, thisArg: any): any;
    function exhaust(): any;
    function exhaustMap(project: any, resultSelector: any): any;
    function expand(project: any, concurrent: any, scheduler: any): any;
    function filter(predicate: any, thisArg: any): any;
    function finalize(callback: any): any;
    function find(predicate: any, thisArg: any): any;
    function findIndex(predicate: any, thisArg: any): any;
    function first(predicate: any, resultSelector: any, defaultValue: any): any;
    function flatMap(project: any, resultSelector: any, concurrent: any): any;
    function groupBy(keySelector: any, elementSelector: any, durationSelector: any, subjectSelector: any): any;
    function ignoreElements(): any;
    function isEmpty(): any;
    function last(predicate: any, resultSelector: any, defaultValue: any): any;
    function map(project: any, thisArg: any): any;
    function mapTo(value: any): any;
    function materialize(): any;
    function max(comparer: any): any;
    function merge(...args: any[]): any;
    function mergeAll(concurrent: any): any;
    function mergeMap(project: any, resultSelector: any, concurrent: any): any;
    function mergeMapTo(innerObservable: any, resultSelector: any, concurrent: any): any;
    function mergeScan(accumulator: any, seed: any, concurrent: any): any;
    function min(comparer: any): any;
    function multicast(subjectOrSubjectFactory: any, selector: any): any;
    function observeOn(scheduler: any, delay: any): any;
    function onErrorResumeNext(...args: any[]): any;
    function pairwise(): any;
    function partition(predicate: any, thisArg: any): any;
    function pluck(...args: any[]): any;
    function publish(selector: any): any;
    function publishBehavior(value: any): any;
    function publishLast(): any;
    function publishReplay(bufferSize: any, windowTime: any, selectorOrScheduler: any, scheduler: any): any;
    function race(...args: any[]): any;
    function reduce(accumulator: any, seed: any, ...args: any[]): any;
    function refCount(): any;
    function repeat(count: any): any;
    function repeatWhen(notifier: any): any;
    function retry(count: any): any;
    function retryWhen(notifier: any): any;
    function sample(notifier: any): any;
    function sampleTime(period: any, scheduler: any): any;
    function scan(accumulator: any, seed: any, ...args: any[]): any;
    function sequenceEqual(compareTo: any, comparor: any): any;
    function share(): any;
    function shareReplay(bufferSize: any, windowTime: any, scheduler: any): any;
    function single(predicate: any): any;
    function skip(count: any): any;
    function skipLast(count: any): any;
    function skipUntil(notifier: any): any;
    function skipWhile(predicate: any): any;
    function startWith(...args: any[]): any;
    function switchAll(): any;
    function switchMap(project: any, resultSelector: any): any;
    function switchMapTo(innerObservable: any, resultSelector: any): any;
    function take(count: any): any;
    function takeLast(count: any): any;
    function takeUntil(notifier: any): any;
    function takeWhile(predicate: any): any;
    function tap(nextOrObserver: any, error: any, complete: any): any;
    function throttle(durationSelector: any, config: any): any;
    function throttleTime(duration: any, scheduler: any, config: any): any;
    function timeInterval(scheduler: any): any;
    function timeout(due: any, scheduler: any): any;
    function timeoutWith(due: any, withObservable: any, scheduler: any): any;
    function timestamp(scheduler: any): any;
    function toArray(): any;
    function window(windowBoundaries: any): any;
    function windowCount(windowSize: any, startWindowEvery: any): any;
    function windowTime(windowTimeSpan: any, ...args: any[]): any;
    function windowToggle(openings: any, closingSelector: any): any;
    function windowWhen(closingSelector: any): any;
    function withLatestFrom(...args: any[]): any;
    function zip(...args: any[]): any;
    function zipAll(project: any): any;
}
export function pipe(...args: any[]): any;
